<!DOCTYPE html>
<html>

<!-- Head tag -->

<head>
 	 <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="Life is short,just coding.">
    <meta name="keyword"  content="undefined">
    <title>JavaWeb学习笔记之Jdbc(二) | Stephen&#39;s blog</title>
    <!-- Favicon -->
    <link rel="Shortcut Icon" href="/favicon.ico">

    <!-- css files -->
    <link rel="stylesheet" href="/css/app.css">
    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/font-awesome.min.css">

</head>

<body>
	<!-- header -->
	<header class="header">
    <section class="banner">
        <div class="banner-image">
            <img src="http://7xl0rs.com1.z0.glb.clouddn.com/banner.png" alt="banner">
        </div>
        <img class="avatar" src="http://7xl0rs.com1.z0.glb.clouddn.com/avatar.png" alt="avatar" >
    </section>

    <nav class="nav">
    
    	<a href="/">Home</a>
    
    	<a href="/archives">Archives</a>
    
    	<a href="/about">About</a>
    
    	<a href="/atom.xml">Rss</a>
    
    </nav>
    <button class="menu-toggle">
        <div class="nav-bar">
             
                <a href="/">Home</a>
            
                <a href="/archives">Archives</a>
            
                <a href="/about">About</a>
            
                <a href="/atom.xml">Rss</a>
            
        </div>
    </button>
    
</header>

	<!-- Main content -->
	<main class="post">

	<article>
	<h1 class="article-title">
	   JavaWeb学习笔记之Jdbc(二)
	</h1>

	<section class="post-time">
		<span class="post-date">10-16</span>
	</section>

	<section class="article-entry">
	    <h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1.事务"></a>1.事务</h2><h3 id="1-1事务的四大特性-ACID"><a href="#1-1事务的四大特性-ACID" class="headerlink" title="1.1事务的四大特性(ACID)"></a>1.1事务的四大特性(ACID)</h3><ul>
<li>1.原子性:事务中的所有操作要么全部执行成功，要么执行全部失败。</li>
<li>2.一致性:事务执行后，数据库状态与其它业务规则保持一致。</li>
<li>3.隔离性:隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰。</li>
<li>4.持久性:一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中。即使提交事务后数据库马上崩溃，在数据库重启后，也必须能保证通过某种机制恢复数据。  </li>
</ul>
<a id="more"></a>
<h3 id="1-2mysql中操作事务"><a href="#1-2mysql中操作事务" class="headerlink" title="1.2mysql中操作事务"></a>1.2mysql中操作事务</h3><p>在控制台中输入语句:<code>start transaction;</code>即开始事务。  </p>
<p>在控制台中输入语句:<code>commit transaction;</code>即提交事务。  </p>
<p>在控制台中输入语句:<code>rollback;</code>回滚事务，即在此事务中执行的操作全部无效，数据库回到<code>start transaction;</code>之前(前提是使用该语法前没有执行<code>commit transaction;</code>操作)。  </p>
<h3 id="1-3Jdbc中操作事务"><a href="#1-3Jdbc中操作事务" class="headerlink" title="1.3Jdbc中操作事务"></a>1.3Jdbc中操作事务</h3><p>在Jdbc中处理事务都是通过Connection对象完成的，同一事务中的所有操作，都在使用同一个Connection对象。  </p>
<p><code>setAutoCommit(boolean);</code>设置是否自动提交事务，如果为true表示自动提交(默认值就是true)，也就是每条执行的sql语句都是一个单独的事务，如果设置false，那么就相当于开启了事务了。<code>con.setAutoCommit(false);</code>语句表示开启事务。  </p>
<p><code>con.commit();</code>提交并结束事务。</p>
<p><code>con.rollback();</code>回滚事务。</p>
<h2 id="2-事务的隔离级别"><a href="#2-事务的隔离级别" class="headerlink" title="2.事务的隔离级别"></a>2.事务的隔离级别</h2><h3 id="2-1事务的并发读问题"><a href="#2-1事务的并发读问题" class="headerlink" title="2.1事务的并发读问题"></a>2.1事务的并发读问题</h3><ul>
<li>脏读:读取到另一份事务未提交数据，即读到了脏数据。</li>
<li>不可重复读：两次读取不一致。对统一记录的两次读取不一致，因为另一事务对该记录做了修改。</li>
<li>幻读：又叫虚读。对同一张表的两次查询不一致，因为另一事务进行了插入了一条记录的操作。</li>
</ul>
<h3 id="2-2四大隔离级别-防止上述问题"><a href="#2-2四大隔离级别-防止上述问题" class="headerlink" title="2.2四大隔离级别(防止上述问题)"></a>2.2四大隔离级别(防止上述问题)</h3><ul>
<li>a.SERIALIZABLE(串行化)：不会出现任何并发问题，因为它是对同一数据的访问是串行的，非并发访问的。性能最差，可能导致死锁。</li>
<li>b.REPEATABLE READ(可重复读)(mysql默认级别)：防止脏读和不可重复读，不能处理幻读问题。性能比a的好。</li>
<li>c.READ COMMITTED(读已提交数据)(Oracle默认级别)：防止脏读，没有处理不可重复读，也没有处理幻读。性能比上述b好。</li>
<li>d.READ UNCOMMITTED(读未提交数据):可能出现任何事务并发问题。性能最好。但基本没人用。  </li>
</ul>
<h3 id="2-3查看mysql的隔离级别"><a href="#2-3查看mysql的隔离级别" class="headerlink" title="2.3查看mysql的隔离级别"></a>2.3查看mysql的隔离级别</h3><p>在控制台中输入语句:<code>select @@tx_isolation;</code>  </p>
<p>也可以通过下面命令来设置隔离级别:<code>set transaction isolationlevel[4选1];</code></p>
<h3 id="2-4在Jdbc中设置隔离级别"><a href="#2-4在Jdbc中设置隔离级别" class="headerlink" title="2.4在Jdbc中设置隔离级别"></a>2.4在Jdbc中设置隔离级别</h3><p><code>con.setTransactionisolation[int lever];</code>  </p>
<h2 id="3-数据库连接池"><a href="#3-数据库连接池" class="headerlink" title="3.数据库连接池"></a>3.数据库连接池</h2><p>用户每次请求都需要向数据库获得链接，而数据库创建连接通常需要消耗相对较大的资源，创建时间也较长。假设网站一天10万访问量，数据库服务器就需要创建10万次连接，极大的浪费数据库的资源，并且极易造成数据库服务器内存溢出、拓机。如下图所示:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.png" alt="">  </p>
<p>数据库连接是一种关键的有限的昂贵的资源,这一点在多用户的网页应用程序中体现的尤为突出.。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正式针对这个问题提出来的。数据库连接池负责分配，管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。如下图所示:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.png" alt="">  </p>
<p>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中, 这些数据库连接的数量是由最小数据库连接数来设定的.无论这些数据库连接是否被使用,连接池都将一直保证至少拥有这么多的连接数量.连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数,当应用程序向连接池请求的连接数超过最大连接数量时,这些请求将被加入到等待队列中。  </p>
<p>数据库连接池的最小连接数和最大连接数的设置要考虑到以下几个因素:  </p>
<ul>
<li><p>1.最小连接数(MinActive):是连接池一直保持的数据库连接,所以如果应用程序对数据库连接的使用量不大,将会有大量的数据库连接资源被浪费。</p>
</li>
<li><p>2.最大连接数(MaxActive):是连接池能申请的最大连接数,如果数据库连接请求超过次数,后面的数据库连接请求将被加入到等待队列中,这会影响以后的数据库操作。</p>
</li>
<li><p>3.如果最小连接数与最大连接数相差很大:那么最先连接请求将会获利,之后超过最小连接数量的连接请求等价于建立一个新的数据库连接.不过,这些大于最小连接数的数据库连接在使用完不会马上被释放,他将被放到连接池中等待重复使用或是空间超时后被释放。  </p>
</li>
</ul>
<h3 id="3-1池参数-所有池参数都有默认值"><a href="#3-1池参数-所有池参数都有默认值" class="headerlink" title="3.1池参数(所有池参数都有默认值)"></a>3.1池参数(所有池参数都有默认值)</h3><pre><code>设置初始化大小:connection.setInitialSize();
设置最小空闲连接数:connection.setMinIdle();
设置最大空闲连接数:connection.setMaxIdle();
设置最小连接数:connection.setMinActive();
设置最大连接数:connection.setMaxActive();
设置增量:一次创建的最小单位。
设置最大的等待时间:connection.setMaxWait();
</code></pre><h3 id="3-2四大连接参数"><a href="#3-2四大连接参数" class="headerlink" title="3.2四大连接参数"></a>3.2四大连接参数</h3><p>连接池也是使用Jdbc中的四大连接参数和驱动jar包来完成创建连接对象。</p>
<h3 id="3-3实现的接口"><a href="#3-3实现的接口" class="headerlink" title="3.3实现的接口"></a>3.3实现的接口</h3><p>连接池必须实现javax.sql.DataSource接口。  </p>
<p>从连接池返回的Connection对象，它的close()方法与众不同。调用它的close()方法不是关闭，而是把连接归还给池。  </p>
<h3 id="3-4DBCP数据库连接池"><a href="#3-4DBCP数据库连接池" class="headerlink" title="3.4DBCP数据库连接池"></a>3.4DBCP数据库连接池</h3><p>DBCP是Apache软件基金组织下的开源连接池实现，要使用DBCP数据源，需要应用程序应在系统中增加如下两个jar文件:</p>
<ul>
<li>Commons-dbcp.jar：连接池的实现</li>
<li>Commons-pool.jar：连接池实现的依赖库</li>
</ul>
<p><strong>Demo:</strong></p>
<pre><code>public class Demo{
    public static void main(String[] args)
    {
        /*
         *1.创建连接池对象
         *2.配置四大参数
         *3.配置池参数
         *4.得到连接对象
         */
        BasicDataSource dataSource=new BasicDataSource();

        dataSource.setDriverClassName(“com.mysql.jdbc.Driver”);
        dataSource.setUrl(“jdbc:mysql://localhost:3306/mydb”);
        dataSource.setUsername(“root”);
        dataSource.setPassword(123);

        dataSource.setMaxActive(20);
        dataSource.setMinIdle(3);
        dataSource.setMaxWait(1000);

        Connection con=dataSource.getConnection();
        System.out.println(con);

      /*
        *连接池内部使用四大参数创建了连接对象，即mysql驱动提供的Connection
        *连接池使用mysql的连接对象进行了装饰，只对close()方法进行了增强！
        *装饰之后的Connection的close()方法，用来把当前连接归还给池
        */
        con.close();//把连接归还给池。
    }
}
</code></pre><p>既然谈到装饰，那下面我们就在下文3.7中来谈谈装饰者模式。  </p>
<h3 id="3-5c3p0数据库连接池"><a href="#3-5c3p0数据库连接池" class="headerlink" title="3.5c3p0数据库连接池"></a>3.5c3p0数据库连接池</h3><p>c3p0,全名叫ComboPooledDataSource;   </p>
<p>需要导入的jar包:</p>
<ul>
<li>连接池的实现:c3p0-0.9.5.2.jar</li>
<li>依赖库:mchange－commons.jar   </li>
</ul>
<p><strong>Demo:</strong></p>
<pre><code>public class Demo{
    public static void main(String[] args)
    {
        //创建连接池对象
        ComboPooledDataSource dataSource=new ComboPooledDataSource();

        //进行四大参数的配置
        dataSource.setDriverClass(“com.mysql.jdbc.Driver”);
        dataSource.setJdbcUrl(“jdbc:mysql://localhost:3306/mydb”);
        dataSource.setUser(&quot;root&quot;);
        dataSource.setPassword(&quot;123&quot;);

        //池配置
        dataSource.setAcquireIncrement(5);
        dataSource.setInitialPoolSize(20);
        dataSource.setMinPoolSize(2);
        dataSource.setMaxPoolSize(50);

        Connection con=dataSource.getConnection();
        System.out.println(con);

        con.close();
    }
}
</code></pre><h4 id="3-5-1c3p0配置文件的使用"><a href="#3-5-1c3p0配置文件的使用" class="headerlink" title="3.5.1c3p0配置文件的使用"></a>3.5.1c3p0配置文件的使用</h4><p>配置文件要求:</p>
<blockquote>
<p>文件名称:必须叫c3p0-config.xml。<br>文件的位置:必须在src下。  </p>
</blockquote>
<p><strong>c3p0配置文件:</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/c3p0%E9%85%8D%E7%BD%AE.png" alt="">  </p>
<p><strong>写入配置文件后的Demo:</strong>  </p>
<pre><code>public class Demo{
    public static void main(String[] args)
    {
        //在创建连接池对象时，这个对象就会自动加载配置文件，不用我们来指定。
        ComboPooledDataSource data=new comboPooledDataSource();
        Connection con=data.getConnection();
        System.out.println(con);
    }
}
</code></pre><h3 id="3-6Tomcat配置数据库连接池"><a href="#3-6Tomcat配置数据库连接池" class="headerlink" title="3.6Tomcat配置数据库连接池"></a>3.6Tomcat配置数据库连接池</h3><h4 id="3-6-1Tomcat配置JNDI资源"><a href="#3-6-1Tomcat配置JNDI资源" class="headerlink" title="3.6.1Tomcat配置JNDI资源"></a>3.6.1Tomcat配置JNDI资源</h4><p><strong>JNDI:</strong>java命名和目录接口。作用:在服务器上配置资源，然后通过统一的方式来获取配置的资源。  </p>
<p>首先需要在Tomcat/conf/Catelina/localhost目录下新建文件名: 项目名.xml  </p>
<p>在该.xml文件中写入以下内容<br><img src="http://od2xrf8gr.bkt.clouddn.com/jdni.png" alt="">  </p>
<h4 id="3-6-1获取资源的代码"><a href="#3-6-1获取资源的代码" class="headerlink" title="3.6.1获取资源的代码"></a>3.6.1获取资源的代码</h4><pre><code>Context initCtx=new InitialContext();//创建一个上下文。

Context envCtx=(Context) initCtx.lookup(“java:comp/env”);//这个路径是固定的不能改。

MyBean bean=(MyBean)envCtx.lookup(“bean/MyBeanFactory”);//通过该上下文进行二次查找才能找到资源。
</code></pre><p><strong>Demo:测试类</strong></p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-17%20%E4%B8%8B%E5%8D%888.43.16.png" alt=""></p>
<h3 id="3-7装饰者模式"><a href="#3-7装饰者模式" class="headerlink" title="3.7装饰者模式"></a>3.7装饰者模式</h3><p>将对象增强的手段有:</p>
<ul>
<li>继承  <blockquote>
<p>缺点:1.增强的内容是死的，不能动。2.被增强的对象也是死的。</p>
</blockquote>
</li>
<li>装饰者模式<blockquote>
<p>特点:1.增强的内容是不能修改的。2.被增强的对象可以是任意的。</p>
</blockquote>
</li>
<li>动态代理(AOP):以后再详讲，博客出来后会给出链接。</li>
</ul>
<p><strong>下面通过一个简单的例子来对装饰者模式进行讲解</strong></p>
<pre><code>class 咖啡类 {};
class 加奶咖啡 extends 咖啡类 {};
class 加糖咖啡 extends 咖啡类 {};
class 加盐咖啡 extends 咖啡类 {};

咖啡 a＝new 加糖咖啡();
咖啡 b＝new 加盐咖啡(a);//对a进行装饰，就是给a加盐
咖啡 c＝new 加奶咖啡(b);//对b进行装饰，就是给b加奶
</code></pre><p>装饰者模式在Java API中的IO流中用到的很多。如BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter、ObjectInputStream、ObjectOutputStream这几个都是运用了装饰模式的装饰流。关于的IO流的详情见下篇博客<a href="http://codingxiaxw.cn/2016/10/17/19-Java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/" target="_blank" rel="external">Java之IO流详解</a>。</p>
<h2 id="4-ThreadLocal"><a href="#4-ThreadLocal" class="headerlink" title="4.ThreadLocal"></a>4.ThreadLocal</h2><p>早在JDK 1.2的版本中就提供Java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。</p>
<h3 id="4-1Thread-API"><a href="#4-1Thread-API" class="headerlink" title="4.1Thread API"></a>4.1Thread API</h3><ul>
<li>void set(Object value);设置当前线程的线程局部变量的值。</li>
<li>Object get();该方法返回当前线程所对应的线程局部变量。</li>
<li>void remove();将当前线程局部变量的值删除，目的是为了减少内存的占用。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。  </li>
</ul>
<h3 id="4-2ThreadLocal内部结构"><a href="#4-2ThreadLocal内部结构" class="headerlink" title="4.2ThreadLocal内部结构"></a>4.2ThreadLocal内部结构</h3><p>ThreadLocal内部用Map来保存数据。虽然在使用上述API时没有给出键，但其实它内部使用了当前线程作为键。内部结构见下面demo:</p>
<pre><code>class ThreadLocal
{
    private Map&lt;Thread,T&gt; map=new HashMap&lt;Thread,T&gt;();

    public void set(T value){

        map.put(Thread.currentThread(),value);
    }

    public void remove(){
        map.remove(Thread.currentThread());
    }

    public T get(){
        return map.get(Thread.currentThread());
    }
}
</code></pre><h2 id="5-dbtils结果集处理器介绍"><a href="#5-dbtils结果集处理器介绍" class="headerlink" title="5.dbtils结果集处理器介绍"></a>5.dbtils结果集处理器介绍</h2><p>需要导入的jar包:</p>
<ul>
<li>common-dbutil.jar</li>
<li>c3p0.jar</li>
<li>mchange-commons.jar</li>
</ul>
<p>关键要得到QueryRunner对象，然后调用其各种方法。</p>
<ul>
<li><p>update()方法:</p>
<blockquote>
<p>1.int update(String sql,Object… params)  可执行增删改语句。<br>2.重载方法int update(Connection con,String sql, Object… params)需要调用者提供Connection，这说明本方法不再管理Connection了。本重载方法支持事务。</p>
</blockquote>
</li>
<li><p>query()方法:</p>
<blockquote>
<p>1.T query (String sql,ResultSetHandler rsh,Object… params)可执行查询操作。<br>2.重载方法:T query(Connection con,String sql,ResultSetHandler rsh,Object… params);  本重载方法支持事务。它会先得到ResultSet，然后调用rsh的handle()把rs转换成需要的类型。</p>
</blockquote>
</li>
<li><p>ResultSetHandler接口</p>
<blockquote>
<p>1.BeanHandler(单行)－－&gt;构造器需要一个class类型的参数，用来把一行结果转换成指定类型的javaBean对象。<br>2.BeanListHandler(多行)—&gt;构造器也是需要一个Class类型的参数，用来把一行结果集转换成一个javabean，哪么多行就是转换成List对象，一堆javabean。<br>3.MapHandler(单行)—&gt;把一行结果集转换成Map对象。<br>4.MapListHandler(多行)—&gt;把一行记录转换成一个Map，多行就是多个Map，即List<map>。<br>5.ScalarHandler(单行单列)－&gt;同来用于select count(＊)from t_stu语句，结果集是单行单列的，它返回一个Object，就是count(*)的值，为long类型。  </map></p>
</blockquote>
</li>
</ul>
<p><strong>dbutil结果处理集原理代码:</strong>  </p>
<pre><code>package demo;
import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

/**
 * Created by codingBoy on 16/10/19.
 */
 public class QR&lt;T&gt;
 {
    private DataSource dataSource;

public QR(DataSource dataSource)
{
    this.dataSource=dataSource;
}

public QR(){
    super();
}

public int update(String sql,Object... params)
{
    Connection con=null;
    PreparedStatement pstmt=null;

    try
    {
        con=dataSource.getConnection();//通过连接池得到连接对象
        pstmt=con.prepareStatement(sql);

        initParams(pstmt,params);//给出参数

        return pstmt.executeUpdate();//调用update执行增、删、该
    }catch (Exception e)
    {
        throw new RuntimeException(e);
    }finally {
        try{
            if (pstmt!=null) pstmt.close();
            if (con!=null) con.close();
        }catch (SQLException e){}
    }
}

//给参数赋值
public void initParams(PreparedStatement pstmt,Object... params) throws SQLException {
    for (int i = 0; i &lt; params.length; i++)
    {
        pstmt.setObject(i+1,params[i]);
    }
}

public T query(String sql,RsHandler&lt;T&gt; rh,Object... params) throws SQLException {
    Connection con=null;
    PreparedStatement pstmt=null;
    ResultSet rs=null;

    try
    {
        con=dataSource.getConnection();//通过连接池得到连接对象
        pstmt=con.prepareStatement(sql);

        initParams(pstmt,params);//给出参数

        rs=pstmt.executeQuery();//调用update执行增、删、该

        return rh.handle(rs);
    }catch (Exception e)
    {
        throw new RuntimeException(e);
    }finally {

        if (rs!=null) rs.close();
        if (pstmt!=null) pstmt.close();
        if (con!=null) con.close();

    }
}

interface RsHandler&lt;T&gt;
{
    public T handle(ResultSet rs);
}
}
</code></pre><p>这样我们以后对数据库进行增、删、改操作时，只需写以下代码即可:</p>
<pre><code>1.QueryRunner qr=new QueryRunner(JdbcUtils.getDataSource);//创建QueryRunner对象，并传入连接池对象

2.String sql=&quot;insert into user values(?,?,?,?);//给出sql语句模板
3.Object[] params={参数1，参数2，参数3，参数4};//传入参数
4.qr.update(sql,params);//调用qr方法。
</code></pre><p>通过这简单的四步就可以对数据库进行增删改了。  </p>
<p>对数据库进行查询操作时，只需写以下代码:  </p>
<pre><code>1.QueryRunner qr=new QueryRunner(JdbcUtils.getDataSource);//创建QueryRunner对象，并传入连接池对象
2.String sql=&quot;select * from user where id=?&quot;;//给出sql语句模板
3. Object[] params={参数};//传入参数
//4. ResultSetHandler&lt;Object&gt; rsh=new ResultSetHandler(){
//        @Override
//        public Object handle(Result rs) throws SQLException{
//            return null;
//        }
//    };
5.Object object=qr.query(sql,new BeanHandler&lt;Object&gt;(Object.class),params);
</code></pre><p>通过这几步即可实现对数据的查询操作了。  </p>
<p><strong>下面的解释写给自己看的:关于connection是否关闭的问题</strong>  </p>
<p>在jar包中，QueryRunner类的update(没有connection参数的)方法，在finally中将connection进行了关闭;在update(有connection参数的)方法中，在finally中没有对connection进行关闭(暂时这么记吧，不然要是进行关闭了的话，在传智播客写的小工具封装类TxQueryRunner中将connection传入JdbcUtils的releaseConnecion()方法中对connection进行关闭时会出现报错)。</p>
<p>在讲到事务时，我们会对QueryRunner进行再次封装。上述写出的QueryRunner的代码只是包中的QueryRunner源码方法的一部分(因为源码中还有很多的重载方法)，我们会通过另一个类TxQueryRunner(较QueryRunner多出的一个功能就是它支持事务)继承该类，在TxQueryrunner类中，对connection进行了判断:若connection为事务中的connection则在TxqueryRunner的update()方法中不对connection进行关闭，而是在commitTransaction()即提交事务时进行关闭;若connection为普通连接，则将connection进行关闭。那么以后我们在DAO中要获取的就不是QueryRunner对象，而是通过<code>QueryRunner qr=new TxQueryRunner();</code>获取TxQueryRunner对象了。</p>
<h2 id="6-联系"><a href="#6-联系" class="headerlink" title="6.联系"></a>6.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>

	</section>	
</article>

</main>

	<!-- footer -->
	<footer>
	<div class="social">
		<a href="https://twitter.com">
			<i class="fa fa-twitter fa-2x" aria-hidden="true"></i>
		</a>
		<a href="https://github.com/stephenLYao">
			<i class="fa fa-github fa-2x" aria-hidden="true"></i>
		</a>
		<a href="http://www.weibo.com/3103316530/profile?rightmod=1&wvr=6&mod=personinfo">
			<i class="fa fa-weibo fa-2x" aria-hidden="true"></i>
		</a>
	</div>
	<p>@2016.Power by <a rel="nofollow"  href="https://hexo.io">Hexo</a>. Theme <a rel="nofollow" href="https://github.com/stephenLYao/hexo-theme-fresh.git">fresh</p>
</footer>


	
	<!-- js -->
	<script type="text/javascript" src="https://cdn.bootcss.com/zepto/1.2.0/zepto.min.js"></script>
	<script src="/js/toggle.js"></script>
</body>
</html>