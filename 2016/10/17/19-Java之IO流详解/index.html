<!DOCTYPE html>
<html>

<!-- Head tag -->

<head>
 	 <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="Life is short,just coding.">
    <meta name="keyword"  content="undefined">
    <title>Java之IO流详解 | Stephen&#39;s blog</title>
    <!-- Favicon -->
    <link rel="Shortcut Icon" href="/favicon.ico">

    <!-- css files -->
    <link rel="stylesheet" href="/css/app.css">
    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/font-awesome.min.css">

</head>

<body>
	<!-- header -->
	<header class="header">
    <section class="banner">
        <div class="banner-image">
            <img src="http://7xl0rs.com1.z0.glb.clouddn.com/banner.png" alt="banner">
        </div>
        <img class="avatar" src="http://7xl0rs.com1.z0.glb.clouddn.com/avatar.png" alt="avatar" >
    </section>

    <nav class="nav">
    
    	<a href="/">Home</a>
    
    	<a href="/archives">Archives</a>
    
    	<a href="/about">About</a>
    
    	<a href="/atom.xml">Rss</a>
    
    </nav>
    <button class="menu-toggle">
        <div class="nav-bar">
             
                <a href="/">Home</a>
            
                <a href="/archives">Archives</a>
            
                <a href="/about">About</a>
            
                <a href="/atom.xml">Rss</a>
            
        </div>
    </button>
    
</header>

	<!-- Main content -->
	<main class="post">

	<article>
	<h1 class="article-title">
	   Java之IO流详解
	</h1>

	<section class="post-time">
		<span class="post-date">10-17</span>
	</section>

	<section class="article-entry">
	    <p>大多数应用程序都需要实现与设备之间的数据传输，例如键盘可以输入数据，显示器可以显示程序的运行结果等。在Java中，将这种通过不同输入输出设备(键盘，内存，显示器，网络等)之间的数据传输抽象表述为”流”，程序允许通过流的方式与输入输出设备进行数据传输。Java中的”流”都位于java.io包中，称为IO(输入输出)流。  </p>
<a id="more"></a>
<p>IO流四大家族:</p>
<ul>
<li>1.InputStream:输入字节流。</li>
<li>2.OutputStream:输出字节流。</li>
<li>3.Reader:输入字符流。</li>
<li>4.Writer:输出字符流。</li>
</ul>
<p>其中1、2统称字节流，3、4统称字符流。接下来就来详细介绍这四大家族流的用法。</p>
<h2 id="1-字节流"><a href="#1-字节流" class="headerlink" title="1.字节流"></a>1.字节流</h2><h3 id="1-1概念"><a href="#1-1概念" class="headerlink" title="1.1概念"></a>1.1概念</h3><p>在计算机中，无论是文本、图片、音频、还是视频，所有的文件都是以二进制(字节)形式存在，IO流中针对字节的输入输出提供了一系列的流，统称为字节流。字节流是程序中最常用的流，根据数据的传输方向可将其分为字节输入流和字节输出流。在JDK中，提供了两个抽象类InputStream和OutputStream，它们是字节流的顶级父类，所有的字节输入流都继承自InputStream，所有的字节输出流都继承自OutputStream。  </p>
<p><strong>注意:</strong>以上所说的所有”输入”、”输出”都是相对于程序而言。数据通过输入流从源设备输入到程序，通过输出流从程序输出到目标设备，从而实现数据的传输。  </p>
<h3 id="1-2字节输入流-InputStream"><a href="#1-2字节输入流-InputStream" class="headerlink" title="1.2字节输入流(InputStream)"></a>1.2字节输入流(InputStream)</h3><p><strong>常用方法:</strong>  </p>
<ul>
<li>int read();从输入流读取一个8位的字节，把它转换成0~255之间的整数，并返回这一整数。</li>
<li>int read(byte[] b);从输入流读取若干字节，把它们保存到参数b指定的字节数组中，返回的整数表示读取字节数。</li>
<li>int read(byte[] b,int off,int len);从输入流读取若干字节，把它们保存到参数b指定的字节数组中，off指定字节数组开始保存数据的起始下标，len表示读取的字节数目。</li>
<li>void close();关闭此输入流并释放与该流关联的所有系统资源。</li>
</ul>
<p>前三个read()方法都是用来读数据的，其中，第一个read()方法是从输入流中逐个读入字节，而第二个和第三个read()方法则将若干字节以字节数组的形式一次性读入，从而提高读数据的效率。在进行IO流操作时，当前IO流会占用一定的内存，由于系统资源宝贵，因此，在IO流操作结束后，应该调用close()方法关闭流，从而释放当前IO流所占的系统资源。 </p>
<p><strong>Demo:读取文件text.txt中的内容</strong>  </p>
<pre><code>import java.io.*;
public class Example{
    public static void main(String[] args){
        FileInputStream in=new FileInputStream(&quot;text.txt&quot;);
        int b;//定义一个int类型的变量，记住每次读取的一个字节。
        while((b=in.read())!=-1)
        {
            System.out.prinln(b);//逐个打印出读取的每一个字节
        }
        in.close();
    }
}
</code></pre><h3 id="1-3字节输出流-OutputStream"><a href="#1-3字节输出流-OutputStream" class="headerlink" title="1.3字节输出流(OutputStream)"></a>1.3字节输出流(OutputStream)</h3><p><strong>常用方法:</strong>  </p>
<ul>
<li>void write(int b);向输出流写入一个字节。</li>
<li>void write(byte[] b);把参数b指定的字节数组的所有字节写到输出流。</li>
<li>void write(byte[] b,int off,int len);将指定byte数组中从偏移量off开始的len个字节写入输出流。</li>
<li>void flush();刷新此输出流并强制写出所有缓冲的输出字节。</li>
<li>void close();关闭此输出流并释放与此流相关的所有系统资源。</li>
</ul>
<p>前三个是重载的write()方法，都是用于向输出流写入字节，其中，第一个方法逐个写入字节，后两个方法是将若干个字节以字节数组的形式一次性写入，从而提高写数据的效率。flush()方法用来将当前输出流缓冲区(通常是字节数组)中的数据强制写入目标设备，此过程称为刷新。close()方法是用来关闭流并释放与当前IO流相关的系统资源。  </p>
<p><strong>Demo:将字符串(首先要将字符串转换为字节)写入到文件中</strong>  </p>
<pre><code>import java.io.*;
public class Example{
    public static void main(String[] args){
        FileOutputStream out=new FileOutputStream(目标文件的路径);
        String str=&quot;hello world&quot;;
        byte[] b=str.getBytes();//字符串调用getBytes()方法即可转换成字节数组。
        for(int i=0;i&lt;b.length;i++)
        {
            out.write(b[i]);
        }
        out.close();
    }
}
</code></pre><p>InputStream和OutputStream这两个类虽然提供了一系列和读写数据有关的方法，但是这两个类都是抽象类，不能被实例化。因此，针对不同的功能，二者提供了不同的子类。</p>
<h3 id="1-4代码示例"><a href="#1-4代码示例" class="headerlink" title="1.4代码示例"></a>1.4代码示例</h3><p>下面这个例子通过对文件的复制来讲解InputStream和OutputStream的用法。  </p>
<pre><code>import java.io.*;
public class Example{
     public static void main(String[] args){
         String fileName=&quot;/Users/codingBoy/Desktop/example1.jpg&quot;;//源文件路径
         String fileName2=&quot;/Users/codingBoy/Desktop/example2.jpg&quot;;//目标文件路径
         InputStream in=null;
         OutputStream out=null;
         try {
             in = new FileInputStream(fileName);
             out = new FileOutputStream(fileName2);
             int b;
             while ((b = in.read())!= -1) {
                 out.write(b);
             }
         }catch (Exception e)
         {
             throw new RuntimeException(e);
          }finally {
             try {
                 if (in != null) in.close();
                if (out!=null) out.close();
             }catch (Exception e)
             {
                 throw new RuntimeException(e);
            }
         }
    }
}
</code></pre><h3 id="1-5字节缓冲流"><a href="#1-5字节缓冲流" class="headerlink" title="1.5字节缓冲流"></a>1.5字节缓冲流</h3><p>上面的例子实现了对文件的复制，但是一个字节一个字节的读写，需要频繁的操作文件，效率非常低。为了提高效率，需要使用两个带缓冲的字节流，分别是BufferedInputStream和BufferedOutputStream,它们两个同时也属于上文<a href="http://codingxiaxw.cn/2016/10/16/18-JavaWeb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BJdbc%E4%BA%8C/" target="_blank" rel="external">JavaWeb学习笔记之Jdbc二</a>中讲到的装饰流。下面通过增加字节缓冲流来对上述例子进行变动:  </p>
<p><strong>Demo:</strong>  </p>
<pre><code>import java.io.*;
public class Example{
     public static void main(String[] args){
        String fileName=&quot;/Users/codingBoy/Desktop/example1.jpg&quot;;//源文件路径
         String fileName2=&quot;/Users/codingBoy/Desktop/example2.jpg&quot;;//目标文件路径
         InputStream in=null;
         OutputStream out=null;
         BufferedInputStream bis=null;
         BufferedOutputStream bos=null;
         try {
             in = new FileInputStream(fileName);
             bis = new BufferedInputStream(in);//将输入流对象作为参数传递给输入缓冲流
             out = new FileOutputStream(fileName2);
             bos = new BufferedOutputStream(out);

             int len;
             while((len=bis.read())!=-1)                 {
                 bos.write(len);
             }
         catch (Exception e)
         {
             throw new RuntimeException(e);
          }finally {
             try {
                 if (in != null) in.close();
                 if (bis!=null) bis.close();
                if (out!=null) out.close();
                if (bos!=null) bos.close();
             }catch (Exception e)
             {
                 throw new RuntimeException(e);
            }
         }
    }
}
</code></pre><h2 id="2-字符流"><a href="#2-字符流" class="headerlink" title="2.字符流"></a>2.字符流</h2><h3 id="2-1定义"><a href="#2-1定义" class="headerlink" title="2.1定义"></a>2.1定义</h3><p>前面我们讲过的InputStream和OutputStream类在读写文件时操作的都是字节，如果希望在程序中操作字符，使用这两个类就不太方便，为此JDK提供了字符流。同字节流一样，字符流也有两个抽象的顶级父类，分别是Reader和Writer。其中Reader是字符输入流，用于从某个源设备读取字符，Writer是字符输出流，用于向某个目标设备写入字符。其API跟字节流的类似。  </p>
<h3 id="2-2输入字符流-Reader"><a href="#2-2输入字符流-Reader" class="headerlink" title="2.2输入字符流(Reader)"></a>2.2输入字符流(Reader)</h3><p><strong>Demo:读取reader.txt中的字符串</strong>  </p>
<pre><code>import java.io.*;
public class Example{
     public static void main(String[] args){
         FileReader reader=new FileReader(&quot;reader.txt&quot;);
         int ch;
         while((ch=reader.read())!=-1)
         {
             System.out.println((char)ch);//通过reader()方法读取到的是int类型的值，所以需要进行强制转换。
         }
         reader.close();
     }
}
</code></pre><h3 id="2-3输出字符流-Writer"><a href="#2-3输出字符流-Writer" class="headerlink" title="2.3输出字符流(Writer)"></a>2.3输出字符流(Writer)</h3><p><strong>Demo:将字符串输出到目标文件中</strong>  </p>
<pre><code>import java.io.*;
public class Example{
    public static void main(String[] args){
        FileWrite out=new FileWrite(目标文件的路径);
        String str=&quot;hello world&quot;;

        out.write(str);
        out.close();
    }
}
</code></pre><h3 id="2-4字符缓冲流"><a href="#2-4字符缓冲流" class="headerlink" title="2.4字符缓冲流"></a>2.4字符缓冲流</h3><p>字符流同样提供了带缓冲区的包装流，分别是BufferedWriter和BufferedReader,其中BufferedReader用于对字符输入流的包装，BufferedWriter用于对字符输出流的包装。需要注意的是，在BufferedReader中有一个重要的方法readLine()，该方法用于一次读取一行文本。接下来通过一个例子学习如何使用这两个包装流实现文件的复制。  </p>
<pre><code>import java.io.*;
public class Example{
     public static void main(String[] args){
         String fileName=&quot;/Users/codingBoy/Desktop/example1.jpg&quot;;//源文件路径
         String fileName2=&quot;/Users/codingBoy/Desktop/example2.jpg&quot;;//目标文件路径
         Reader reader=null;
         BufferedReader bf=null;
         Writer writer=null;
         BufferedWriter bw=null;
         try {
             reader = new Reader(fileName);
             br=new BufferedReader(reader);
             writer = new Writer(fileName2);
             bw=new BufferedWriter(writer);
             String str;
             while ((str = bf.readLine())!= null) {
                 bw.write(str);
                 bw.newLine();//写入一个换行符，该方法会根据不同的操作系统生成相应的换行符。
             }
         }catch (Exception e)
         {
             throw new RuntimeException(e);
          }finally {
             try {
                 if (reader != null) reader.close();
                 if (br !=null) br.close();
                if (writer!=null) writer.close();
                if (bw !=null) bw.close();
             }catch (Exception e)
             {
                 throw new RuntimeException(e);
            }
         }
    }
}
</code></pre><h2 id="3-转换流"><a href="#3-转换流" class="headerlink" title="3.转换流"></a>3.转换流</h2><p>前面提到IO流可分为字节流和字符流，有时自己流和字符流之间也需要进行转换。在JDK中提供了两个类可以将字节流转换为字符流，它们分别是InputStreamReader和OutputStreamWriter。  </p>
<p>转换流也是一种包装流，其中OutputStreamWriter是Writer的子类，它可以将一个字节输出流包装成字符输出流，方便直接写入字符，而InputStreamReader是Reader的子类，它可以将一个字节输入流包装成字符输入流，方便直接读取字符。  </p>
<p><strong>Demo:将字节流转换为字符流</strong>  </p>
<pre><code>import java.io.*;
public class Example{
     public static void main(String[] args){
         String fileName=&quot;/Users/codingBoy/Desktop/example1.jpg&quot;;//源文件路径
         String fileName2=&quot;/Users/codingBoy/Desktop/example2.jpg&quot;;//目标文件路径
         InputStreamReader isr=new InputStreamReader(new FileInputStream(fileName1));
         BufferedReader br=new BufferedReader(isr);

         OutputStreamWriter osw=new OutputStreamWriter(new FileOutputStream(fileName2));
         BufferedWriter bw=new BufferedWriter(osw);

         String line;
         while((line=br.readLine())!=null)
         {
             bw.write(line);
         }

         br.close();
         bw.close();
     }
}
</code></pre><h2 id="4-其他IO流"><a href="#4-其他IO流" class="headerlink" title="4.其他IO流"></a>4.其他IO流</h2><h4 id="4-1ByteArrayInputStream和ByteArrayOutputStream"><a href="#4-1ByteArrayInputStream和ByteArrayOutputStream" class="headerlink" title="4.1ByteArrayInputStream和ByteArrayOutputStream"></a>4.1ByteArrayInputStream和ByteArrayOutputStream</h4><p>在前面的学习中，都是将文件直接存储到硬盘，但有时候我们希望将文件临时存储到缓冲区，方便以后读取。为此JDK中提供了一个ByteArrayOutputStream类。该类会在创建对象时就创建一个byte型数组的缓冲区，当向数组中写数据时，该对象会把所有的数据先写入缓冲区，最后一次行写入文件。<br><strong>Demo:将数据写入缓冲区</strong>  </p>
<pre><code>import java.io.*;
public class Example{
     public static void main(String[] args){
         String fileName1=&quot;/Users/codingBoy/Desktop/example1.jpg&quot;;//源文件路径
         String fileName2=&quot;/Users/codingBoy/Desktop/example2.jpg&quot;;//目标文件路径
         FileInputStream in=new FileInputStream(fileName1);
         ByteArrayOutputStream bos=new ByteArrayOutputStream();
         FileOutputStream out=new FileOutputStream(fileName2);

         int b;
         while((b=in.read())!=-1)
         {
             bos.write(b);//先将数据写入缓冲区，当需要写入目标文件中的时候再调用输出流的write(bos.toByteArray())方法。
         }

         in.close();
         bos.close();
         out.write(bos.toByteArray());
         out.close();
}
</code></pre><p>在该例中，定义了一个ByteArrayOutputStream对象，将从fileName1文件中读取的字节全部写入该对象的缓冲区，通过FileOutputStream对象将缓冲区的数据一次性写入fileName2文件。  </p>
<p>与ByteArrayOutputStream类似，ByteArrayInputStream是从缓冲区中读取数据，接下来通过一个案例来演示ByteArrayInputStream如何读取缓冲区的数据。  </p>
<p><strong>Demo:</strong></p>
<pre><code>import java.io.*;
public class Example{
     public static void main(String[] args){
         byte[] bytes=new byte[]{97,98,99,100};
         ByteArrayInputStream bis=new ByteArrayInputStream(bytes);

         int b;
         while((b=bis.read())!=-1)
         {
             System.out.println((char)b);
         }
}
</code></pre><h2 id="5-联系"><a href="#5-联系" class="headerlink" title="5.联系"></a>5.联系</h2><p>If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="codingxiaxw.cn">blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><p><a href="https://github.com/codingXiaxw" target="_blank" rel="external">github@codingXiaxw</a> </p>
</li>
</ul>

	</section>	
</article>

</main>

	<!-- footer -->
	<footer>
	<div class="social">
		<a href="https://twitter.com">
			<i class="fa fa-twitter fa-2x" aria-hidden="true"></i>
		</a>
		<a href="https://github.com/stephenLYao">
			<i class="fa fa-github fa-2x" aria-hidden="true"></i>
		</a>
		<a href="http://www.weibo.com/3103316530/profile?rightmod=1&wvr=6&mod=personinfo">
			<i class="fa fa-weibo fa-2x" aria-hidden="true"></i>
		</a>
	</div>
	<p>@2016.Power by <a rel="nofollow"  href="https://hexo.io">Hexo</a>. Theme <a rel="nofollow" href="https://github.com/stephenLYao/hexo-theme-fresh.git">fresh</p>
</footer>


	
	<!-- js -->
	<script type="text/javascript" src="https://cdn.bootcss.com/zepto/1.2.0/zepto.min.js"></script>
	<script src="/js/toggle.js"></script>
</body>
</html>