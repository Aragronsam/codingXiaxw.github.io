<!DOCTYPE html>
<html>

<!-- Head tag -->

<head>
 	 <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="Life is short,just coding.">
    <meta name="keyword"  content="undefined">
    <title>Java Web中实现Servlet的方式 | Stephen&#39;s blog</title>
    <!-- Favicon -->
    <link rel="Shortcut Icon" href="/favicon.ico">

    <!-- css files -->
    <link rel="stylesheet" href="/css/app.css">
    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/font-awesome.min.css">

</head>

<body>
	<!-- header -->
	<header class="header">
    <section class="banner">
        <div class="banner-image">
            <img src="http://7xl0rs.com1.z0.glb.clouddn.com/banner.png" alt="banner">
        </div>
        <img class="avatar" src="http://7xl0rs.com1.z0.glb.clouddn.com/avatar.png" alt="avatar" >
    </section>

    <nav class="nav">
    
    	<a href="/">Home</a>
    
    	<a href="/archives">Archives</a>
    
    	<a href="/about">About</a>
    
    	<a href="/atom.xml">Rss</a>
    
    </nav>
    <button class="menu-toggle">
        <div class="nav-bar">
             
                <a href="/">Home</a>
            
                <a href="/archives">Archives</a>
            
                <a href="/about">About</a>
            
                <a href="/atom.xml">Rss</a>
            
        </div>
    </button>
    
</header>

	<!-- Main content -->
	<main class="post">

	<article>
	<h1 class="article-title">
	   Java Web中实现Servlet的方式
	</h1>

	<section class="post-time">
		<span class="post-date">09-24</span>
	</section>

	<section class="article-entry">
	    <h2 id="1-Servlet是什么"><a href="#1-Servlet是什么" class="headerlink" title="1.Servlet是什么?"></a>1.Servlet是什么?</h2><p>Servlet是Java Web三大组件之一，它属于动态资源。Servlet的作用是处理请求，服务器会把接收到的请求交给Servlet来处理，在Servlet中通常需要:  </p>
<ul>
<li>接受数据请求</li>
<li>处理请求</li>
<li><p>完成响应  </p>
<a id="more"></a>
</li>
</ul>
<p>例如客户端发出登录请求，或者输入注册请求，这些请求都应该由Servlet来完成处理。当然Servlet类需要我们自己来编写，每个Servlet类都必须实现javax.servlet.Servlet接口。  </p>
<h2 id="2-实现Servlet的方式-需要我们自己来写"><a href="#2-实现Servlet的方式-需要我们自己来写" class="headerlink" title="2.实现Servlet的方式(需要我们自己来写)"></a>2.实现Servlet的方式(需要我们自己来写)</h2><ol>
<li>实现javax.servlet.Servlet接口;</li>
<li>继承javax.servlet.GenericServlet类;</li>
<li>继承javax.servlet.http.HttpServlet类;  </li>
</ol>
<p>一般来说我们都选择实现HttpServlet类来完成我们的Servlet，但学习Servlet还要从javax.servlet.Servlet接口来学起。  </p>
<h3 id="2-1实现javax-servlet-Servlet接口"><a href="#2-1实现javax-servlet-Servlet接口" class="headerlink" title="2.1实现javax.servlet.Servlet接口"></a>2.1实现javax.servlet.Servlet接口</h3><p>实现该接口的代码如下，需要实现该接口中的5个方法(各个方法的作用见注释)。  </p>
<p>   <img src="http://od2xrf8gr.bkt.clouddn.com/%E5%AE%9E%E7%8E%B0Servlet%E6%8E%A5%E5%8F%A3.png" alt="">  </p>
<p>其中只有三个生命周期的方法是由服务器(例如我用的Tomcat)在认为需要调用的时候自动调用的(即我们自己是无法调用的)，另外的两个方法由我们自己需要的时候调用。   </p>
<h3 id="2-2继承javax-servlet-GenericServlet类"><a href="#2-2继承javax-servlet-GenericServlet类" class="headerlink" title="2.2继承javax.servlet.GenericServlet类"></a>2.2继承javax.servlet.GenericServlet类</h3><p>有人会说，那我每次实现Servlet接口都要重写这5个方法岂不是很麻烦？那肯定麻烦！所以GenericServlet类派上用场了。  </p>
<p>GenericServlet类实现了Servlet接口，所以在GenericServlet类中实现了Servlet接口中的5个抽象方法，另外在GenerecServlet类中还定义了自己的方法，将其作为我们要定义的xxxServlet类的父类，这样我们在自己定义的xxxServlet类中便可以不用<strong>全部</strong>实现Servlet接口中的方法。  </p>
<p>GenericServlet类中的方法如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/GenericServlet%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%85%A8%E9%83%A8%E6%96%B9%E6%B3%95.png" alt="">  </p>
<p>由图可知，GenericServlet类除了实现Servlet接口中的四个方法外，还定义了getInitParameter()返回Servlet的参数值、getInitParameterNames()返回Servlet的参数名、getServletName()返回Servlet名、getServletContext()返回Servlet上下文、不带参数的init()、log()等方法。这些自己定义的方法中，前面四个是ServletConfig接口中的方法，不带参数的init()方法跟Servlet接口中的init(ServletConfig config)方法要区别，在init()方法中，我们可以添加当xxxServlet被初始化的操作，此方法在初始化方法init(ServletConfig config)中被调用(若是文字解析看不懂见下图GenericServlet源代码中注释)。  </p>
<p>另外不知道你们发现了没有，图中只有service()方法属于抽象方法，所以当我们定义的xxxServlet类去继承GenericServlet类时我们只需重写这一个方法即可，其他方法可重写可不重写。  </p>
<p>另外附上GenericServlet类的源代码:<br><img src="http://od2xrf8gr.bkt.clouddn.com/GenericServlet%E7%B1%BB%E6%BA%90%E4%BB%A3%E7%A0%81.jpg" alt="">  </p>
<p>代码中的xxxServlet类即是我们自己定义的servlet类。  </p>
<p>扩展:<strong>对ServletContext的解释</strong>:  </p>
<p>服务器会为每个应用创建一个ServletContext对象，一个应用只有一个ServletContext对象！我们可以在N多个Servlet中来获取这个唯一的对象，使用它可以给多个Servlet传递数据。此对象在Tomcat(服务器)启动时就创建，在服务器关闭时就销毁。  </p>
<p>ServletContext是Java Web四大域对象(PageContext、ServletRequest、HttpSession、ServletContext)之一，域对象所具有的特点是:  </p>
<ul>
<li>能够存数据</li>
<li>能够取数据  </li>
</ul>
<p>所有的域对象都有存取数据的功能，因为域对象内部有一个Map，用来存储数据，下面是ServletContext对象用来操作数据的方法:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/ServletContext%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95.png" alt="">  </p>
<p>扩展:<strong>Servlet类三大域:</strong>  </p>
<ul>
<li>request:在Servlet中直接用，因为实现的doPost()方法中有request这个参数。</li>
<li>session:在Servlet中通过<code>HttpSession session=request.getSession();</code>得到。</li>
<li>application:在Servlet中通过<code>ServletContext application=this.getServletContext();</code>得到。</li>
</ul>
<p>扩展:<strong>JSP中四大域</strong></p>
<ul>
<li>page域:即9大内置对象中的pageContext，为PageContext的实例。注意:“page域”不同于9大内置对象中“page”。</li>
<li>request域:即9大内置对象中的request，为HttpServletRequest的实例。</li>
<li>session域:即9大内置对象中的session,为HttpSession的实例。</li>
<li>application:即9大内置对象中的ServletContext的实例。</li>
</ul>
<h3 id="2-3-继承HttpServlet类"><a href="#2-3-继承HttpServlet类" class="headerlink" title="2.3.继承HttpServlet类"></a>2.3.继承HttpServlet类</h3><p>HttpServlet类是我们用到次数最多的，也是最简单的。由类名可知，该类总是跟http协议相关的。  </p>
<p>HttpServlet类中的方法如下图:<br><img src="http://od2xrf8gr.bkt.clouddn.com/httpservlet%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95.png" alt=""><br>方法中值得我们注意的有doGet()、doPost()、还有两个service()方法。其中doGet()和doPost()方法是需要我们重写的，我来解释下两个service()方法的区别。  </p>
<p>估计你们从方法中的参数就知道他们的区别了吧，其中一个service()方法是Serlvet接口中的生命周期方法，另外一个是跟http协议有关的方法。二者方法的解释见下两站图的说明(图1中指出HttpServlet类是继承自GenderServlet类):<br><img src="http://od2xrf8gr.bkt.clouddn.com/httpServlet%E4%B8%AD%E5%AF%B9service%E6%96%B9%E6%B3%95%E7%9A%84%E8%A7%A3%E9%87%8A.png" alt=""><br>uml(时序图)如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt=""><br>图中405的含义是说服务器不支持客户端(即浏览器)用此种方法访问。因为HttpServlet类的源代码中的doGet()和doPost()方法体里面就是这样写的，你在定义的xxxservlet中如果不重新重写这两个方法就会出现405的响应状态码。接下来我们看看如何继承HttpServlet类:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%AE%9E%E7%8E%B0httpservlet%E7%B1%BB.png" alt=""><br>FServlet即为我们自己定义的servlet类，在doGet()方法和doPost()方法中即可写具体要进行的操作。  </p>
<p>如上三种方式便可实现我们自己定义的Servlet类。  </p>
<hr>
<h2 id="3-联系"><a href="#3-联系" class="headerlink" title="3.联系"></a>3.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn" target="_blank" rel="external">blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">github@codingXiaxw</a></li>
</ul>

	</section>	
</article>

</main>

	<!-- footer -->
	<footer>
	<div class="social">
		<a href="https://twitter.com">
			<i class="fa fa-twitter fa-2x" aria-hidden="true"></i>
		</a>
		<a href="https://github.com/stephenLYao">
			<i class="fa fa-github fa-2x" aria-hidden="true"></i>
		</a>
		<a href="http://www.weibo.com/3103316530/profile?rightmod=1&wvr=6&mod=personinfo">
			<i class="fa fa-weibo fa-2x" aria-hidden="true"></i>
		</a>
	</div>
	<p>@2016.Power by <a rel="nofollow"  href="https://hexo.io">Hexo</a>. Theme <a rel="nofollow" href="https://github.com/stephenLYao/hexo-theme-fresh.git">fresh</p>
</footer>


	
	<!-- js -->
	<script type="text/javascript" src="https://cdn.bootcss.com/zepto/1.2.0/zepto.min.js"></script>
	<script src="/js/toggle.js"></script>
</body>
</html>